I include:

Solidity contracts (complete, commented): Vault, Market, Settlement, PreInteractionAdapter, PostInteractionAdapter, a small MockOracle for testing and an interface for the 1inch protocol caller-check.

Integration guide with exact calldata encoding to use inside the 1inch order (extension, predicate, preInteraction, postInteraction).

Hardhat / ethers JS examples showing: maker creates & signs order (pseudocode using 1inch SDK), taker / relayer simulating fill (how settlement should be called), and how to encode the hooks.

Security & production notes.

Implementation assumptions & conventions (kept consistent in the code):

Collateral token = ERC20 (e.g., USDC). We treat token decimals as raw units; you must adapt scaling for price math in production.

Price oracle exposes getPrice() returning uint256 price scaled to 1e18.

We expose onlyLimitOrderProtocol modifier for hook contracts (settable by owner) — set this to the deployed 1inch LimitOrderProtocol address on mainnet/testnet.

The 1inch order preInteraction and postInteraction fields are generic bytes; we pass ABI-encoded calldata using abi.encodeWithSelector(...) so the LimitOrder settlement will call those exact functions on the specified target contracts.

1) Full Solidity contract set

Paste these files into contracts/ in your Hardhat project.

interfaces/ILimitOrderProtocol.sol

(Just small interface used to record who the protocol is — optional)

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface ILimitOrderProtocol {
    // marker for allowed caller checks (not required)
}

contracts/FuturesVault.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title FuturesVault
 * @dev Keeps collateral for both makers and takers. Exposes lock/unlock/credit APIs.
 * Only Market and Settlement contracts should be allowed to move funds; we manage roles
 * by owner-settable addresses (market, settlement, pre/post adapters).
 */
contract FuturesVault is Ownable {
    IERC20 public collateral;

    // roles
    address public market;
    address public settlement;
    address public preInteractionAdapter;
    address public postInteractionAdapter;

    mapping(address => uint256) public balance;    // unlocked collateral (user deposit)
    mapping(address => uint256) public locked;     // locked margin per user

    event Deposit(address indexed who, uint256 amount);
    event Withdraw(address indexed who, uint256 amount);
    event Lock(address indexed who, uint256 amount);
    event Unlock(address indexed who, uint256 amount);
    event Credit(address indexed who, uint256 amount); // used to forward maker funds

    constructor(IERC20 _collateral) {
        collateral = _collateral;
    }

    // --- role setters ---
    function setMarket(address _m) external onlyOwner { market = _m; }
    function setSettlement(address _s) external onlyOwner { settlement = _s; }
    function setPreInteractionAdapter(address _a) external onlyOwner { preInteractionAdapter = _a; }
    function setPostInteractionAdapter(address _a) external onlyOwner { postInteractionAdapter = _a; }

    // --- user deposits & withdraws (unlocked balance) ---
    function deposit(uint256 amount) external {
        require(amount > 0, "zero");
        collateral.transferFrom(msg.sender, address(this), amount);
        balance[msg.sender] += amount;
        emit Deposit(msg.sender, amount);
    }

    function withdraw(uint256 amount) external {
        require(amount <= balance[msg.sender], "insufficient");
        // ensure that withdrawal won't break their positions: Market should check; keep simple here
        balance[msg.sender] -= amount;
        collateral.transfer(msg.sender, amount);
        emit Withdraw(msg.sender, amount);
    }

    // --- called by preInteraction adapter to lock taker collateral
    function lockFromPreInteraction(address who, uint256 amount) external {
        require(msg.sender == preInteractionAdapter, "only pre-adapter");
        require(balance[who] >= amount, "insufficient balance");
        balance[who] -= amount;
        locked[who] += amount;
        emit Lock(who, amount);
    }

    // --- called by PostInteraction to finalize credit/lock operations
    function creditMaker(address who, uint256 amount) external {
        // credit is used to receive maker margin forwarded from settlement
        require(msg.sender == settlement, "only settlement");
        locked[who] += amount;
        emit Credit(who, amount);
    }

    function unlockAndReturn(address who, uint256 amount) external {
        // Market may call this to unlock and return to unlocked balance (e.g., closing with leftover)
        require(msg.sender == market, "only market");
        require(locked[who] >= amount, "locked too low");
        locked[who] -= amount;
        balance[who] += amount;
        emit Unlock(who, amount);
    }

    function forceTransferFromSettlement(address to, uint256 amount) external {
        // Settlement uses this to forward maker funds directly to an external recipient
        require(msg.sender == settlement, "only settlement");
        collateral.transfer(to, amount);
    }

    // helpers for Market to check
    function lockedOf(address who) external view returns (uint256) { return locked[who]; }
    function balanceOf(address who) external view returns (uint256) { return balance[who]; }
}

contracts/MockOracle.sol (for local testing)
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract MockOracle {
    uint256 public price; // scaled 1e18

    constructor(uint256 _p) {
        price = _p;
    }

    function setPrice(uint256 _p) external {
        price = _p;
    }

    function getPrice() external view returns (uint256) {
        return price;
    }
}

contracts/FuturesMarket.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "./FuturesVault.sol";

contract FuturesMarket is Ownable {
    FuturesVault public vault;
    address public oracle; // must provide getPrice() -> uint256 (1e18)
    uint256 public nextPositionId;

    uint16 public maintenancePercent; // e.g., 50 => 50% of initial margin

    struct Position {
        address maker;
        address taker;
        int256 size; // signed base size (positive => maker long, negative => maker short)
        uint256 notional; // scaled in collateral units
        uint256 entryPrice; // 1e18
        uint256 makerMargin; // locked in vault
        uint256 takerMargin; // locked in vault
    }

    mapping(uint256 => Position) public positions;
    mapping(address => uint256[]) public ownerPositions;

    event PositionOpened(uint256 indexed pid, address indexed maker, address indexed taker, int256 size, uint256 notional);
    event PositionClosed(uint256 indexed pid, address indexed closer);
    event Liquidated(uint256 indexed pid, address indexed liquidator, uint256 penalty);

    constructor(FuturesVault _vault, address _oracle, uint16 _maintPct) {
        vault = _vault;
        oracle = _oracle;
        maintenancePercent = _maintPct;
        nextPositionId = 1;
    }

    // --- Only the postInteraction adapter should call openBilateralPosition
    function openBilateralPosition(
        address maker,
        address taker,
        int256 signedSize,
        uint256 notional,
        uint256 makerMargin,
        uint256 takerMargin
    ) external returns (uint256) {
        // caller check: enforce only postInteraction adapter (owner-settable)
        require(msg.sender == owner(), "only owner-post-adapter-or-owner"); // we recommend owner be set to PostInteractionAdapter OR further refine
        // basic sanity
        require(maker != taker, "same parties");

        uint256 pid = nextPositionId++;
        uint256 price = MockOracle(oracle).getPrice();

        positions[pid] = Position({
            maker: maker,
            taker: taker,
            size: signedSize,
            notional: notional,
            entryPrice: price,
            makerMargin: makerMargin,
            takerMargin: takerMargin
        });
        ownerPositions[maker].push(pid);
        ownerPositions[taker].push(pid);

        emit PositionOpened(pid, maker, taker, signedSize, notional);
        return pid;
    }

    // Close a position (either side may call). We will do simple settlement:
    // compute PnL for maker = size * (curPrice - entryPrice)
    // migrate collateral appropriately and unlock remainder into vault balances.
    function closePosition(uint256 pid) external {
        Position storage p = positions[pid];
        require(p.maker != address(0), "no pos");
        uint256 curPrice = MockOracle(oracle).getPrice();

        // compute signed PnL for maker:
        // PnL_maker = size * (curPrice - entryPrice) / 1e18
        int256 priceDelta = int256(curPrice) - int256(p.entryPrice);
        int256 pnlMaker = (p.size * priceDelta) / int256(1e18);

        // compute settlement transfers: we will convert signed pnl to transfer from one side's locked margin to the other
        if (pnlMaker > 0) {
            uint256 pnl = uint256(pnlMaker);
            // cap to takerMargin
            uint256 paid = pnl > p.takerMargin ? p.takerMargin : pnl;
            // transfer from taker locked -> maker unlocked
            // reduce locked on taker and increase balance on maker
            FuturesVault(vault).unlockAndReturn(p.taker, p.takerMargin - paid); // remainder back to balance
            FuturesVault(vault).unlockAndReturn(p.maker, p.makerMargin + paid); // maker gets pnl + maker margin returned
        } else {
            uint256 loss = uint256(-pnlMaker);
            uint256 paid = loss > p.makerMargin ? p.makerMargin : loss;
            FuturesVault(vault).unlockAndReturn(p.maker, p.makerMargin - paid);
            FuturesVault(vault).unlockAndReturn(p.taker, p.takerMargin + paid);
        }

        emit PositionClosed(pid, msg.sender);
        delete positions[pid];
    }

    // Simple liquidation: anyone can call if equity < maintenance requirement (in collateral units)
    function liquidate(uint256 pid) external {
        Position storage p = positions[pid];
        require(p.maker != address(0), "no pos");
        uint256 curPrice = MockOracle(oracle).getPrice();
        int256 priceDelta = int256(curPrice) - int256(p.entryPrice);
        int256 pnlMaker = (p.size * priceDelta) / int256(1e18);

        // equity for maker = makerMargin + pnlMaker
        int256 makerEquity = int256(p.makerMargin) + pnlMaker;
        uint256 maint = (p.notional * maintenancePercent) / 100;

        if (makerEquity < int256(maint)) {
            // simple: liquidator gets 5% of maker margin as reward
            uint256 penalty = (p.makerMargin * 5) / 100;
            // send penalty from vault locked maker margin to liquidator
            FuturesVault(vault).forceTransferFromSettlement(msg.sender, penalty); // settlement acts as forwarder; here allowed for simplicity
            // remaining locked amounts go back to parties based on naive split to keep example short
            // production: compute exact shortfall & distribution
            emit Liquidated(pid, msg.sender, penalty);
            delete positions[pid];
        } else revert("not undercollateralized");
    }
}


NOTE: In the above FuturesMarket.openBilateralPosition we used a simple owner check. In deployment you should set owner to the post-interaction adapter or use a dedicated postInteractionAdapter role setter. I kept code compact for hackathon readability. Replace MockOracle type with your real oracle interface in production.

contracts/FuturesSettlement.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./FuturesVault.sol";

/**
 * @dev Settlement endpoint which is intended to be the `recipient` of a 1inch swap.
 * Flow:
 *  - 1inch executes swap, delivers `makerAmount` tokens to this contract
 *  - Settlement.forwardToVault(maker, market, makerAmount, encodedPostInteractionData)
 *    -> this will deposit makerAmount into the Vault by calling vault.creditMaker(...)
 *    -> then it calls the postInteraction adapter (external) to open the bilateral position.
 *
 * In testing you can call forwardToVault directly to simulate 1inch finalizing a swap.
 */
contract FuturesSettlement {
    FuturesVault public vault;
    address public owner; // deployer or admin
    address public postAdapter; // postInteraction adapter contract

    event MakerReceived(address indexed maker, uint256 amount, bytes data);
    event ForwardedToVault(address indexed maker, uint256 amount, uint256 pid);

    constructor(FuturesVault _vault, address _postAdapter) {
        vault = _vault;
        postAdapter = _postAdapter;
        owner = msg.sender;
    }

    function setPostAdapter(address _a) external {
        require(msg.sender == owner, "owner");
        postAdapter = _a;
    }

    // called by 1inch settlement (or simulated by relayer)
    // `maker` is the maker address which created the order,
    // `market` is the futures market address to open the position on,
    // `makerAmount` is amount of collateral delivered for maker's margin (already in this contract),
    // `postInteractionData` is abi-encoded bytes to pass to the post adapter (it should include maker,taker, signedSize, leverage, market, makerAmount, takerMargin, etc).
    function forwardToVault(address maker, address market, uint256 makerAmount, bytes calldata postInteractionData) external returns (uint256) {
        // move the makerAmount from this contract to the vault contract (we assume tokens have been transferred here)
        IERC20 col = vault.collateral();
        // approve or transfer - we will call vault.forceTransferFromSettlement for simplicity
        col.transfer(address(vault), makerAmount);
        // credit maker in vault (this call must be protected inside Vault)
        vault.creditMaker(maker, makerAmount);

        emit MakerReceived(maker, makerAmount, postInteractionData);

        // call post adapter to open the bilateral position (postAdapter should be owner-controlled)
        // expected signature of postAdapter: function onPostInteraction(address market, bytes calldata data) external returns (uint256 pid)
        (bool ok, bytes memory ret) = postAdapter.call(abi.encodeWithSignature("onPostInteraction(address,bytes)", market, postInteractionData));
        require(ok, "post call failed");

        uint256 pid = abi.decode(ret, (uint256));
        emit ForwardedToVault(maker, makerAmount, pid);
        return pid;
    }

    // fallback rescue by owner for testing
    function rescue(IERC20 token, address to, uint256 amount) external {
        require(msg.sender == owner, "owner");
        token.transfer(to, amount);
    }
}

contracts/PreInteractionAdapter.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./FuturesVault.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @dev PreInteraction adapter: called by 1inch prior to settlement to lock taker collateral.
 * Expect calldata encoded as:
 * abi.encode(uint256 takerRequiredMargin)
 *
 * The LimitOrder `preInteraction` should be set to call this adapter with
 * calldata = abi.encodeWithSelector(PreInteractionAdapter.preInteraction.selector, taker, data)
 */
contract PreInteractionAdapter is Ownable {
    FuturesVault public vault;
    address public limitOrderProtocol; // optional check - set to 1inch protocol contract

    event PreInteractionCalled(address indexed taker, uint256 amount);

    constructor(FuturesVault _vault) {
        vault = _vault;
    }

    function setLimitOrderProtocol(address p) external onlyOwner { limitOrderProtocol = p; }
    function setVault(FuturesVault v) external onlyOwner { vault = v; }

    // Called by 1inch settlement engine before finalizing the order fill.
    // We expect msg.sender to be 1inch protocol (optional check)
    // `taker` is the taker who is filling the order
    // `data` must be abi.encode(uint256 requiredMargin)
    function preInteraction(address taker, bytes calldata data) external {
        // optional enforcement: require(msg.sender == limitOrderProtocol, "only protocol");
        uint256 required = abi.decode(data, (uint256));
        // require taker has approved vault: user must have previously deposited via vault.deposit or given approvals
        // For our design we'll pull from taker's unlocked balance inside Vault, so require the taker already deposited.
        // lockFromPreInteraction will deduct unlocked balance and increase locked amount
        vault.lockFromPreInteraction(taker, required);
        emit PreInteractionCalled(taker, required);
    }
}

contracts/PostInteractionAdapter.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./FuturesVault.sol";
import "./FuturesMarket.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @dev PostInteraction adapter: called after settlement has deposited maker funds to the vault.
 * Expected `data` abi-encoding:
 * abi.encode(address maker, address taker, int256 signedSize, uint16 leverage, uint256 makerMargin, uint256 takerMargin)
 *
 * The adapter will call market.openBilateralPosition(...).
 */
contract PostInteractionAdapter is Ownable {
    FuturesVault public vault;
    FuturesMarket public market;

    event PostInteractionCalled(address indexed maker, address indexed taker, uint256 pid);

    constructor(FuturesVault _vault, FuturesMarket _market) {
        vault = _vault;
        market = _market;
    }

    function setVault(FuturesVault v) external onlyOwner { vault = v; }
    function setMarket(FuturesMarket m) external onlyOwner { market = m; }

    // Called by FuturesSettlement after maker funds are credited into vault
    // Returns pid as bytes (so settlement can decode)
    function onPostInteraction(address marketAddr, bytes calldata data) external returns (uint256) {
        // decode
        (address maker, address taker, int256 signedSize, uint16 leverage, uint256 makerMargin, uint256 takerMargin, uint256 notional) = abi.decode(data, (address, address, int256, uint16, uint256, uint256, uint256));

        // NOTE: additional checks can be added: ensure vault.lockedOf(maker) >= makerMargin, vault.lockedOf(taker) >= takerMargin
        require(vault.lockedOf(maker) >= makerMargin, "maker margin not locked");
        require(vault.lockedOf(taker) >= takerMargin, "taker margin not locked");

        // Call the market to open the bilateral position
        uint256 pid = FuturesMarket(marketAddr).openBilateralPosition(maker, taker, signedSize, notional, makerMargin, takerMargin);

        emit PostInteractionCalled(maker, taker, pid);
        // return pid encoded
        return pid;
    }
}

2) Integration guide — how to wire everything to 1inch Limit Order

Below steps assume you have deployed the above contracts and the 1inch Limit Order Protocol contract (on testnet or local fork).

Deployment order (recommended)

Deploy ERC20 mock (USDC), deploy FuturesVault with that token.

Deploy MockOracle and set initial price.

Deploy FuturesMarket with vault & oracle; set the market owner to your PostInteractionAdapter owner or set required roles (or leave owner as deployer and later set adapter owner).

Deploy PreInteractionAdapter and PostInteractionAdapter with references to Vault and Market.

Deploy FuturesSettlement with Vault and set postAdapter to your PostInteractionAdapter address.

In Vault, call setSettlement(settlementAddr) and setPreInteractionAdapter(preAdapterAddr) and setPostInteractionAdapter(postAdapterAddr) and setMarket(marketAddr).

In PreInteractionAdapter and PostInteractionAdapter, set owner & roles appropriately.

Set limitOrderProtocol in preAdapter (optional) to the 1inch LimitOrderProtocol address and enable the onlyLimitOrderProtocol style checks if you want.

Order construction (maker side)

We create a private limit order where:

makerToken = USDC

takerToken = USDC (settles in same collateral) — you can adapt to cross-token design if required

makerAmount = makerMargin (maker margin amount in USDC raw units)

takerAmount = takerMargin (taker margin amount in USDC raw units) — this value can be used as informational only because taker margin will be pulled at fill-time by preInteraction; but putting it into the order helps ensure both sides have intended sizes.

Important fields to set:

allowedSender = takerAddress
— makes the order private: only takerAddress can fill.

predicate — ensure both parties have deposited (optional if you want full safety): encode a call to Vault that verifies both parties have at least the specified unlocked amount:

// predicate calldata
bytes memory predicate = abi.encodeWithSelector(
    Vault.checkBothHaveUnlocked.selector, // you can add this helper (not in sample code) or call vault.balanceOf
    makerAddress,
    takerAddress,
    makerMargin,
    takerMargin,
    expiryTimestamp
);


Because we didn't add checkBothHaveUnlocked method in the vault above, you can either:

add a view helper to the Vault that returns balance[maker] >= makerMargin && balance[taker] >= takerMargin && block.timestamp < expiry, OR

omit the predicate and rely on preInteraction + settlement sequence to enforce.

preInteraction — this must be calldata that calls your PreInteractionAdapter.preInteraction(taker, abi.encode(requiredMargin)). Example:

// JS / ethers: build preInteraction bytes
const preData = ethers.utils.defaultAbiCoder.encode(["uint256"], [takerMargin]);
const preInteractionCalldata = preAdapterContract.interface.encodeFunctionData("preInteraction", [takerAddress, preData]);
order.preInteraction = {
  target: preAdapterAddress,
  data: preInteractionCalldata
}


1inch expects preInteraction in its order schema as the calldata to call on the target contract — check their SDK for exact field names (often preInteraction is bytes where you put the calldata and preInteractionTarget set separately). If the SDK expects a single preInteraction bytes that is executed on the allowedTarget you must set that correctly. See the 1inch docs / SDK (use their LimitOrder builder).

postInteraction — similar: after settlement, 1inch settlement will call this or our FuturesSettlement will call post adapter. For reliability, we route settlement to FuturesSettlement.forwardToVault(...) and then FuturesSettlement calls PostInteractionAdapter.onPostInteraction(market, data).

postInteractionData: encode the arguments expected by PostInteractionAdapter.onPostInteraction:

// (maker, taker, signedSize, leverage, makerMargin, takerMargin, notional)
const postData = ethers.utils.defaultAbiCoder.encode(
  ["address","address","int256","uint16","uint256","uint256","uint256"],
  [makerAddr, takerAddr, signedSize, leverage, makerMargin, takerMargin, notional]
);

Typical fill flow (taker / relayer)

Taker (or relayer) submits fill to the 1inch fillOrder endpoint, passing the signed order and specifying:

recipient: the FuturesSettlement contract address, or using 1inch’s standard recipient semantics to route final funds to settlement.

1inch preInteraction call is invoked: it calls your PreInteractionAdapter.preInteraction(taker, data). That function locks takerMargin from the taker’s unlocked vault balance (the taker must have deposited into Vault earlier). Alternatively, you can allow preInteraction to transferFrom directly from taker to vault if the taker has not pre-deposited — adapt preInteraction to either lockFromPreInteraction (requires deposit) or pull from taker with transferFrom.

1inch swaps execute; final makerAmount is transferred to the recipient (our FuturesSettlement).

FuturesSettlement.forwardToVault(maker, market, makerAmount, postInteractionData) is called (this may be done automatically by 1inch if recipient is settlement), or FuturesSettlement receives tokens then the relayer calls forwardToVault(...).

Settlement forwards maker funds to Vault.creditMaker(maker, makerAmount).

Settlement invokes PostInteractionAdapter.onPostInteraction(marketAddr, postData) which calls market.openBilateralPosition(...).

Market opens the position and records the bilateral trade: both sides’ margins are locked in the vault, position metadata persisted, and trades start accruing PnL & funding per your market logic.

3) Example JS snippets (ethers + Hardhat) — encoding & simulating the flow

Below are example snippets. Use the official 1inch Limit Order SDK to handle the EIP-712 signing; this shows how to encode preInteraction & postInteraction bytes.

encode preInteraction calldata (ethers)
const preAdapterIface = new ethers.utils.Interface(["function preInteraction(address taker, bytes data)"]);
const preData = ethers.utils.defaultAbiCoder.encode(["uint256"], [takerMargin]);
const preInteractionCalldata = preAdapterIface.encodeFunctionData("preInteraction", [takerAddress, preData]);

// For the limit order, set preInteractionTarget = PRE_ADAPTER_ADDR, preInteraction = preInteractionCalldata

encode postInteraction calldata (to pass into Settlement)
const postData = ethers.utils.defaultAbiCoder.encode(
  ["address","address","int256","uint16","uint256","uint256","uint256"],
  [makerAddress, takerAddress, signedSize, leverage, makerMargin, takerMargin, notional]
);

// In the 1inch order, you typically set recipient = FUTURES_SETTLEMENT_ADDR.
// The settlement will receive makerAmount tokens and you (relayer) call settlement.forwardToVault(maker, marketAddr, makerAmount, postData).

simulated relayer fill (local/hardhat)
// PSEUDOCODE for testing without full 1inch:
// 1) PreInteraction (simulate 1inch calling the pre-interaction)
await preAdapter.connect(relayer).preInteraction(takerAddress, ethers.utils.defaultAbiCoder.encode(["uint256"], [takerMargin]));

// 2) Simulate swap: transfer makerAmount from maker to Settlement (or mint in test)
await usdc.connect(makerSigner).transfer(futuresSettlement.address, makerMargin);

// 3) Call Settlement.forwardToVault to deposit maker margin & call post adapter
await futuresSettlement.connect(relayer).forwardToVault(makerAddress, market.address, makerMargin, postData);

// After above, the position should exist in market.positions(pid)

Signing the order (use 1inch SDK)

Using the official 1inch SDK is strongly recommended for proper limit order EIP-712 signatures. Typical pseudocode:

import { LimitOrderBuilder } from '@1inch/limit-order-sdk';
const builder = new LimitOrderBuilder(chainId, limitOrderProtocolAddress);

// build order object with fields, and set:
// allowedSender: takerAddress
// makerAmount: makerMargin
// takerAmount: takerMargin (informational)
// recipient: futuresSettlementAddress (so maker funds land there)
// preInteraction: preInteractionCalldata
// preInteractionTarget: preAdapterAddress
// extension: postData or other metadata you want embedded

const limitOrder = builder.buildLimitOrder(orderFields);
const signature = await builder.signLimitOrder(limitOrder, makerPrivateKey);


(Exact SDK calls vary — consult the 1inch Limit Order SDK docs for building & signing. We used preInteraction and recipient as conceptual fields; check the SDK’s field names and pack these bytes accordingly.)